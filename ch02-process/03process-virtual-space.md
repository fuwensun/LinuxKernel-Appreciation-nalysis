# 进程的虚拟地址空间
-  mm
-  active_mm

linux把虚拟地址空间分为两部分:内核空间和用户空间。
以面向对象的视角来看可以称内核空间实例和用户空间实例，内核空间实例是静态创建的而且就一个；用户空间实例是动态创建的，可以有多个，而且可以创建也可以销毁。
```
            +---------------------------------------------------+
            |                                                   |
            |                  kernel space #0                  |
            |                                                   |
            +---------------------------------------------------+
            |            |            |            |            |
            |   user     |   user     |            |   user     |
            |   space    |   space    |  .......   |   space    |
            |   #1       |   #2       |            |   #n       |
            |            |            |            |            |
            +------------+------------+------------+------------+
```
内核空间又称为匿名空间，同样用户空间又称为真实空间。为何这样称了，从用户空间的角度看，用户空间的每个角落即每个字节，它都能访问而且有访问的权限。而内核空间了，用户空间知道内空间的存在，因为知道内核空间的地址，但是也仅仅是知道它的地址而已，当它去访问时会报缺页错误。一句话概括就是用户空间知道内核空间的存在，但无权访问，基于这点称内核空间为匿名空间。
```c
struct task_struct {
  	struct mm_struct		*mm;
	struct mm_struct		*active_mm;
}
```

进程描述的mm字段表示该进程拥有的真实空间；active_mm表示目前正在使用/激活的真实空间。为什么没有一个字段指向匿名空间了？因为它是全局静态的唯一的存在实例，它一直占据着物理内存，它不会换出也不会销毁，一直处于激活状态，所以不需要对它的引用。而真实的空间是动态创建的实例，它会载入和换出物理内存，也会销毁，所以需要一个索引才能操作它。
